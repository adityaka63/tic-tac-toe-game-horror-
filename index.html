<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Contract</title>
    <style>
        /* UI & HUD STYLES */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Verdana', sans-serif; /* Friendly font initially */
            background-color: #87CEEB; /* Sky Blue */
            user-select: none;
            -webkit-user-select: none;
            color: #333;
            touch-action: none;
            transition: background-color 2s, color 2s;
        }

        /* HORROR MODE CLASS overrides */
        body.horror-mode {
            font-family: 'Courier New', Courier, monospace;
            background-color: #050505;
            color: #bbaaaa;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        /* Blood Vignette Overlay */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 60%, rgba(50, 0, 0, 0) 100%);
            transition: background 0.1s; /* Fast transition for blood hits */
            opacity: 0;
            z-index: 5;
        }
        body.horror-mode #vignette { opacity: 1; }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid rgba(50, 50, 50, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none; 
        }
        body.is-desktop #crosshair { display: block; }
        body.horror-mode #crosshair { border-color: rgba(150, 150, 150, 0.5); }
        
        #crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #333;
            transform: translate(-50%, -50%);
            box-shadow: none;
        }
        body.horror-mode #crosshair-dot { background: #aa0000; box-shadow: 0 0 5px #ff0000; }

        /* Top HUD */
        #hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        body.horror-mode #hud-top { text-shadow: 0 0 5px #000; }

        /* Body Parts Bar */
        #body-parts-bar {
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.5);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            display: none; 
        }
        body.horror-mode #body-parts-bar {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #442222;
            border-radius: 0;
        }

        .body-part {
            padding: 5px;
            border: 1px solid #999;
            color: #333;
            font-size: 0.8rem;
            position: relative;
        }
        body.horror-mode .body-part { border-color: #555; color: #ddd; }
        
        .body-part.lost {
            color: #550000;
            border-color: #330000;
            text-decoration: line-through;
            opacity: 0.6;
        }
        .body-part.lost::after {
            content: "X";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 1.5rem;
            font-weight: bold;
        }

        #winnings-display {
            color: #228822; /* Green initially */
            font-weight: bold;
            font-size: 1.2rem;
            background: rgba(255,255,255,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        body.horror-mode #winnings-display { 
            color: #d4af37; 
            background: none; 
            border-radius: 0;
        }

        /* Dialogue Box */
        #dialogue-container {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #aaa;
            padding: 20px;
            color: #222;
            display: none;
            text-align: center;
            pointer-events: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 20;
        }
        body.horror-mode #dialogue-container {
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #552222;
            color: #ccc;
            border-radius: 2px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #dialogue-text {
            font-size: 1.1rem;
            margin-bottom: 15px;
            line-height: 1.5;
            font-style: normal;
        }
        body.horror-mode #dialogue-text { font-style: italic; }

        .btn {
            background: #eee;
            color: #333;
            border: 1px solid #ccc;
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            border-radius: 5px;
        }
        .btn:hover { background: #ddd; }

        body.horror-mode .btn {
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            border-radius: 0;
        }
        body.horror-mode .btn:hover { background: #440000; color: #fff; border-color: #880000; }

        /* Contract UI */
        #contract-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            height: auto;
            max-height: 90vh;
            overflow-y: auto;
            background: #fff;
            color: #222;
            padding: 30px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            font-family: 'Verdana', sans-serif;
            z-index: 100;
            border-radius: 8px;
        }
        body.horror-mode #contract-container {
            background: #dcd0b0; /* Parchment */
            color: #221;
            box-shadow: 0 0 50px #000;
            font-family: 'Times New Roman', serif;
            border-radius: 0;
        }

        #contract-text {
            flex-grow: 1;
            font-size: 1rem;
            line-height: 1.4;
        }
        #signature-area {
            border: 2px dashed #999;
            background: #fff;
            cursor: crosshair;
            margin: 10px 0;
            width: 100%;
            touch-action: none;
        }
        body.horror-mode #signature-area {
            border-color: #554;
            background: #eeeadd;
        }
        
        /* Notifications */
        #notification {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #225522;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            font-family: inherit;
            letter-spacing: 2px;
            text-align: center;
            width: 100%;
        }
        body.horror-mode #notification {
            color: #880000;
            text-shadow: 0 0 10px black;
            font-family: 'Times New Roman', serif;
        }

        /* Hunt UI */
        #hunt-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 200;
            pointer-events: none;
        }
        #hunt-header {
            font-size: 8rem;
            color: #ff0000;
            margin: 0;
            text-shadow: 0 0 20px #500;
            letter-spacing: 10px;
            animation: pulse 0.5s infinite alternate;
        }
        #hunt-countdown {
            font-size: 6rem;
            color: #cc0000;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
        }
        @keyframes pulse { from { transform: scale(1); opacity: 0.8; } to { transform: scale(1.1); opacity: 1; } }

        /* Jumpscare Overlay */
        #jumpscare-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #jumpscare-face {
            width: 60vh;
            height: 60vh;
            background: #ffccaa; /* Skin tone */
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 50px #500 inset;
            animation: scare-zoom 0.8s infinite alternate cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }
        /* Eyes */
        .scare-eye {
            position: absolute;
            top: 35%;
            width: 15%;
            height: 15%;
            background: red;
            border-radius: 50%;
            box-shadow: 0 0 20px red;
        }
        .scare-eye.left { left: 25%; }
        .scare-eye.right { right: 25%; }
        /* Mouth */
        .scare-mouth {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 30%;
            border-bottom: 2vh solid black;
            border-radius: 50%;
            background: transparent;
        }
        /* Hat */
        .scare-hat-brim {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 120%;
            height: 10%;
            background: #111;
            border-radius: 50%;
        }
        .scare-hat-top {
            position: absolute;
            bottom: 85%;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            height: 60%;
            background: #111;
        }

        @keyframes scare-zoom {
            0% { transform: scale(0.2) rotate(-5deg); }
            50% { transform: scale(1.5) rotate(5deg); }
            100% { transform: scale(0.9) rotate(-2deg); }
        }

        /* Interaction Prompt */
        #interact-prompt {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            font-size: 1rem;
            display: none;
            opacity: 0.8;
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 4px;
        }
        body.horror-mode #interact-prompt {
            color: #ccc;
            text-shadow: 1px 1px 2px black;
            background: none;
        }

        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #87CEEB; /* Happy Sky */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #333;
            z-index: 999;
            pointer-events: auto;
            transition: background 1s;
        }
        body.horror-mode #blocker {
            background: #000;
            color: #888;
        }

        .menu-view {
            text-align: center;
            display: none; /* Hidden by default, toggled via JS */
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 400px;
        }

        .menu-view h1, .menu-view h2 { 
            font-family: 'Verdana', serif; 
            color: #225588; 
            letter-spacing: 2px; 
            margin-bottom: 20px;
        }
        body.horror-mode .menu-view h1, body.horror-mode .menu-view h2 {
            font-family: 'Times New Roman', serif;
            color: #aa4444;
            letter-spacing: 5px;
        }
        
        .menu-btn { 
            background: #fff;
            border: 1px solid #888; 
            color: #333; 
            padding: 15px;
            font-family: inherit;
            font-size: 1.2rem;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 5px;
        }
        .menu-btn:hover { 
            background: #eef; 
            color: #000; 
            border-color: #448; 
        }
        body.horror-mode .menu-btn {
            background: transparent;
            border: 1px solid #444; 
            color: #888;
            border-radius: 0;
        }
        body.horror-mode .menu-btn:hover { 
            background: #220000; 
            color: #ccaaaa; 
            border-color: #884444; 
        }

        /* Slider Styles */
        .setting-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 15px;
            color: inherit;
        }
        input[type=range] {
            width: 100%;
            background: #ddd;
            accent-color: #225588;
        }
        body.horror-mode input[type=range] {
            background: #333;
            accent-color: #880000;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            display: none; /* Shown via JS detection */
        }

        .mobile-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid rgba(100, 100, 100, 0.4);
            border-radius: 50%;
            color: #222;
            font-weight: bold;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
        }
        body.horror-mode .mobile-btn {
            background: rgba(50, 50, 50, 0.3);
            border: 2px solid rgba(150, 150, 150, 0.4);
            color: rgba(255, 255, 255, 0.7);
        }

        /* Pause Button (Top Right) */
        #btn-pause-mobile { top: 20px; right: 20px; width: 50px; height: 50px; border-radius: 8px; font-size: 0.8rem; }

        /* D-Pad Container (Bottom Left) */
        #dpad-container { position: absolute; bottom: 40px; left: 40px; width: 150px; height: 150px; }
        #btn-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-down { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { top: 50px; right: 0; width: 50px; height: 50px; }

        /* Jump (Bottom Right) */
        #btn-jump-mobile { bottom: 60px; right: 40px; width: 80px; height: 80px; font-size: 1rem; }

        /* Context Interaction (Near Jump) */
        #btn-interact-mobile { bottom: 160px; right: 40px; width: 70px; height: 70px; border-color: #225588; color: #225588; background: rgba(200, 220, 255, 0.5); display: none; }
        body.horror-mode #btn-interact-mobile { border-color: #ffff00; color: #ffff00; background: rgba(50, 50, 0, 0.3); }

    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="vignette"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="hud-top">
            <div id="body-parts-bar">
                <!-- Populated via JS -->
            </div>
            <div id="winnings-display">$0</div>
        </div>

        <div id="crosshair"><div id="crosshair-dot"></div></div>
        <div id="notification"></div>
        <div id="hunt-ui">
            <h1 id="hunt-header">RUN</h1>
            <div id="hunt-countdown">3</div>
        </div>
        <div id="interact-prompt">[E] Speak</div>
    </div>

    <!-- Jumpscare Overlay -->
    <div id="jumpscare-overlay">
        <div id="jumpscare-face">
            <div class="scare-hat-top"></div>
            <div class="scare-hat-brim"></div>
            <div class="scare-eye left"></div>
            <div class="scare-eye right"></div>
            <div class="scare-mouth"></div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <button id="btn-pause-mobile" class="mobile-btn">MENU</button>
        <div id="dpad-container">
            <button id="btn-up" class="mobile-btn">^</button>
            <button id="btn-left" class="mobile-btn"><</button>
            <button id="btn-right" class="mobile-btn">></button>
            <button id="btn-down" class="mobile-btn">v</button>
        </div>
        <button id="btn-interact-mobile" class="mobile-btn">SPEAK</button>
        <button id="btn-jump-mobile" class="mobile-btn">JUMP</button>
    </div>

    <!-- Dialogue Box -->
    <div id="dialogue-container">
        <div id="dialogue-text">...</div>
        <button id="dialogue-btn" class="btn">Continue</button>
    </div>

    <!-- Contract UI -->
    <div id="contract-container">
        <h2 style="text-align: center; text-decoration: underline;">Participation Agreement</h2>
        <div id="contract-text">
            <p>I, the undersigned, hereby join the friendly competition hosted by The Dealer.</p>
            <p><strong>REWARD:</strong> For each victory, I shall receive one gold bar valued at $1,000,000.</p>
            <p><strong>PENALTY:</strong> For each failure, The Dealer shall collect one piece of my physical being as payment.</p>
            <p style="font-size: 0.8rem; color: #888;">Standard liability waiver. Terms are non-negotiable.</p>
        </div>
        <label>Sign Here:</label>
        <canvas id="signature-area" width="440" height="100"></canvas>
        <button id="sign-btn" class="btn" style="width: 100%; margin-top: 10px;">Sign Up!</button>
    </div>

    <!-- MAIN MENU BLOCKER -->
    <div id="blocker">
        
        <!-- View 1: Initial Start -->
        <div id="menu-start" class="menu-view">
            <h1>TIC-TAC-TOE</h1>
            <p style="color: #333;">A fun game in the park!</p>
            <p style="font-size: 0.8rem; color: #444;">WASD / Touch to Move</p>
            <button id="btn-wake-up" class="menu-btn">Start Day</button>
        </div>

        <!-- View 2: Pause Menu -->
        <div id="menu-pause" class="menu-view">
            <h2>MENU</h2>
            <button id="btn-continue" class="menu-btn">Continue</button>
            <button id="btn-settings" class="menu-btn">Settings</button>
        </div>

        <!-- View 3: Settings -->
        <div id="menu-settings" class="menu-view">
            <h2>SETTINGS</h2>
            
            <div class="setting-row">
                <label>Sensitivity: <span id="sens-value">2.0</span></label>
                <input type="range" id="sens-slider" min="0.5" max="5.0" step="0.1" value="2.0">
            </div>

            <div class="setting-row">
                <label>Volume: <span id="vol-value">1.0</span></label>
                <input type="range" id="vol-slider" min="0.0" max="1.0" step="0.1" value="1.0">
            </div>

            <button id="btn-back" class="menu-btn" style="margin-top: 10px;">Back</button>
        </div>

    </div>

    <script>
        const CONFIG = {
            moveSpeed: 30.0,
            runSpeedMultiplier: 1.8, 
            jumpForce: 15.0, 
            gravity: 35.0,
            playerHeight: 1.7,
            interactDist: 4.5,
            boardBaseHeight: 0.0,
            boardCellSize: 1.5,
            topRowHeightThreshold: 2.8,
            sensitivity: 0.002,
            footstepInterval: 0.56,
            
            // Horror Config
            initialEasyWins: 3,
            fogDensity: 0.012, 
            rainCount: 2000
        };

        const HORROR_STATE = {
            isActive: false, // Starts false (Happy Mode)
            contractSigned: false,
            bodyParts: [
                { name: "L. Eye", lost: false },
                { name: "R. Ear", lost: false },
                { name: "Fingers", lost: false },
                { name: "Teeth", lost: false },
                { name: "Skin", lost: false },
                { name: "Soul", lost: false } 
            ],
            currentWinnings: 0,
            drawStreak: 0,
            gamesWon: 0,
            isGlitching: false,
            isDead: false,
            cheatUsedThisRound: false,
            drawsBeforeCheating: 3 
        };

        const STATE = {
            hasStarted: false,
            isPlaying: false,
            isDialogue: false,
            isContract: false,
            isRunning: false,
            turn: 'player', 
            board: Array(9).fill(null),
            gameActive: false,
            gameEnded: false,
            isMobile: false 
        };

        const HUNT_STATE = {
            active: false,
            timer: 3,
            npcSpeed: 5.1, 
            npcSprintSpeed: 9.18, 
            captureDist: 1.5,
            isDragging: false,
            isExtracting: false, 
            isJumpscaring: false, // Jumpscare state
            dragStartTime: 0,
            dragDuration: 2000,
            dragStartPos: new THREE.Vector3(),
            npcStartPos: new THREE.Vector3(4, 0, -8),
            npcFootstepTimer: 0
        };

        // --- DIALOGUE ARRAYS ---
        const DIALOGUE_HAPPY = [
            "Hello there! Lovely day for a game, isn't it?",
            "I'm just a humble businessman looking for a friendly match.",
            "Care to play Tic-Tac-Toe? I have prizes!",
            "Oh, the paper? Just a standard liability waiver.",
            "Don't worry about the fine print, just a formality.",
            "You win, you get $1,000,000. Simple as that!",
            "Ready to have some fun?"
        ];

        const DIALOGUE_HORROR_INTRO = [
            "Greetings... traveler.",
            "The air... tastes different now.",
            "I have a contract. Win, and you keep earning.",
            "Lose... and I take a piece of you.",
            "Just a finger here, an ear there. You won't miss them.",
            "Do we have a deal?"
        ];

        const DIALOGUE_BODY_PART_LOSS = [
            "Another piece... for the collection.",
            "You were not using that anyway.",
            "Flesh is transient. Gold is eternal.",
            "A fair trade... I assure you.",
            "Do you feel lighter?",
            "Delicious...",
            "The contract... demands it."
        ];

        const DIALOGUE_CHEAT_WARNING = [
            "THE AIR GROWS COLD...",
            "SOMETHING IS WATCHING...",
            "THE SHADOWS LENGTHEN...",
            "REALITY BENDS...",
            "HE GROWS IMPATIENT...",
            "DO NOT BLINK..."
        ];

        const DIALOGUE_CHEAT_EXECUTE = [
            "I make the rules now.",
            "Did you think you could win?",
            "Mine.",
            "Look away.",
            "It moves..."
        ];

        /**
         * ------------------------------------------------------------------
         * THREE.JS SETUP
         * ------------------------------------------------------------------
         */
        let camera, scene, renderer;
        let controls, pitchObj, handsGroup;
        let leftHand, rightHand; 
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3(); 
        let prevTime = performance.now();
        let footstepTimer = 0;

        let boardMeshes = [];
        let placedPieces = [];
        let npcMesh, npcEyes, npcMouth;
        let boardGroup, resetButtonMesh; 
        let rainGeo, rainSystem;
        let flashLight, sunLight, ambientLight; 
        let fireLights = []; 
        let clouds = []; 
        
        // Materials References for Swapping
        let groundMat, treeLeafMat, treeTrunkMat, skyCloudMat;

        let colliders = [];
        const playerSize = new THREE.Vector3(0.8, 1.8, 0.8);
        const playerBox = new THREE.Box3();

        // Audio System
        let audioCtx;
        let masterGain; 
        let rainNode, happyAmbienceNode;
        let demonOsc1, demonOsc2, demonGain, demonFilter, demonShaper;
        let happyTalkOsc, happyTalkGain;

        // Touch Tracking
        let lastTouchX = null, lastTouchY = null;
        let touchDragId = null;
        
        // Jumpscare Light (Removed, using 2D overlay)

        init();
        animate();

        function init() {
            // Detect Mobile
            STATE.isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (STATE.isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.body.classList.remove('is-desktop');
                CONFIG.sensitivity *= 3.0; // Touch needs higher sens
            } else {
                document.body.classList.add('is-desktop');
            }

            scene = new THREE.Scene();
            // Happy Sky Color Initially
            scene.background = new THREE.Color(0x87CEEB); 
            // Minimal white fog initially
            scene.fog = new THREE.FogExp2(0xFFFFFF, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffee, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // NPC Fire Lights (Hidden initially)
            const npcLight = new THREE.PointLight(0xaa4400, 0, 10);
            npcLight.position.set(4, 0.5, -7);
            scene.add(npcLight);
            fireLights.push({ light: npcLight, base: 1.0, flicker: 0.3 });

            flashLight = new THREE.DirectionalLight(0x8899aa, 0);
            flashLight.position.set(20, 50, 20);
            scene.add(flashLight);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            setupControls();
            setupMobileControls();
            createWorld();
            createSky();
            createRain();
            setupInteractUI();

            raycaster = new THREE.Raycaster();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick); 
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
            
            document.getElementById('dialogue-btn').addEventListener('click', advanceDialogue);
            setupMenuLogic();
        }

        // --- MENU LOGIC ---
        function setupMenuLogic() {
            document.getElementById('btn-wake-up').addEventListener('click', () => {
                STATE.hasStarted = true;
                if (!STATE.isMobile) document.body.requestPointerLock();
                else {
                    STATE.isPlaying = true;
                    document.getElementById('blocker').style.display = 'none';
                }
                if (!audioCtx) initAudio();
                else if (audioCtx.state === 'suspended') audioCtx.resume();
            });

            document.getElementById('btn-continue').addEventListener('click', () => {
                if (!STATE.isMobile) document.body.requestPointerLock();
                else {
                    STATE.isPlaying = true;
                    document.getElementById('blocker').style.display = 'none';
                }
            });

            document.getElementById('btn-settings').addEventListener('click', () => {
                document.getElementById('menu-pause').style.display = 'none';
                document.getElementById('menu-settings').style.display = 'flex';
            });

            document.getElementById('btn-back').addEventListener('click', () => {
                document.getElementById('menu-settings').style.display = 'none';
                document.getElementById('menu-pause').style.display = 'flex';
            });

            document.getElementById('sens-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('sens-value').innerText = val.toFixed(1);
                CONFIG.sensitivity = val / 1000;
            });

            document.getElementById('vol-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('vol-value').innerText = val.toFixed(1);
                if(masterGain) masterGain.gain.setTargetAtTime(val, audioCtx.currentTime, 0.1);
            });

            showMenu('start');
        }

        function showMenu(type) {
            const start = document.getElementById('menu-start');
            const pause = document.getElementById('menu-pause');
            const settings = document.getElementById('menu-settings');
            start.style.display = 'none'; pause.style.display = 'none'; settings.style.display = 'none';
            if(type === 'start') start.style.display = 'flex';
            else if(type === 'pause') pause.style.display = 'flex';
            else if(type === 'settings') settings.style.display = 'flex';
        }

        function createSky() {
            const cloudGeo = new THREE.SphereGeometry(15, 8, 8);
            skyCloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for(let i=0; i<15; i++) {
                const cloud = new THREE.Mesh(cloudGeo, skyCloudMat);
                cloud.scale.set(2 + Math.random(), 0.3, 1.5 + Math.random());
                cloud.position.set((Math.random()-0.5)*200, 30+Math.random()*10, (Math.random()-0.5)*200);
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        function createWorld() {
            const groundGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
            const posAttr = groundGeo.attributes.position;
            for(let i=0; i<posAttr.count; i++) posAttr.setZ(i, Math.random() * 0.5);
            groundGeo.computeVertexNormals();
            
            // Ground Mat - Lighter initially
            groundMat = new THREE.MeshStandardMaterial({ color: 0x557755, roughness: 1.0, flatShading: true });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            function addCollider(mesh) { mesh.updateMatrixWorld(true); colliders.push(new THREE.Box3().setFromObject(mesh)); }

            // Tree Mats - Lighter initially
            treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x664422, roughness: 1.0 });
            treeLeafMat = new THREE.MeshStandardMaterial({ color: 0x228822, roughness: 0.9 });

            for(let i=0; i<60; i++) {
                const height = 10 + Math.random() * 15;
                const x = (Math.random() - 0.5) * 120;
                const z = (Math.random() - 0.5) * 120;
                if(Math.abs(x) < 20 && Math.abs(z) < 20) continue; 
                const treeGroup = new THREE.Group();
                treeGroup.position.set(x, 0, z);
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, height, 6), treeTrunkMat);
                trunk.position.y = height/2;
                treeGroup.add(trunk);
                const levels = 3 + Math.floor(Math.random()*2);
                for(let j=0; j<levels; j++) {
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(3 - j*0.6, 4 + Math.random()*2, 7), treeLeafMat);
                    cone.position.y = height - j*2.5;
                    treeGroup.add(cone);
                }
                scene.add(treeGroup);
                const box = new THREE.Box3();
                box.setFromCenterAndSize(new THREE.Vector3(x, height/2, z), new THREE.Vector3(1.5, height, 1.5));
                colliders.push(box);
            }

            createCampfire(7, 0, -6);

            boardGroup = new THREE.Group();
            boardGroup.position.set(0, 0, -10);
            scene.add(boardGroup);

            const frame = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 0.5), new THREE.MeshStandardMaterial({ color: 0x554433, roughness: 0.9 }));
            frame.position.y = 2.5 + CONFIG.boardBaseHeight;
            frame.userData.isSolid = true;
            boardGroup.add(frame);

            createTorch(frame, -2.5, 5.2, 0); 
            createTorch(frame, 2.5, 5.2, 0);  

            const gap = CONFIG.boardCellSize + 0.1;
            for (let i = 0; i < 9; i++) {
                const row = Math.floor(i / 3);
                const col = i % 3;
                const cell = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.boardCellSize, CONFIG.boardCellSize), new THREE.MeshStandardMaterial({ color: 0xDDDDDD, side: THREE.DoubleSide }));
                cell.position.set((col - 1) * gap, 2.5 + (1 - row) * gap, 0.26);
                cell.userData = { index: i, type: 'cell', row: row };
                boardGroup.add(cell);
                boardMeshes.push(cell);
            }

            const pedestal = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.8), new THREE.MeshLambertMaterial({ color: 0x444444 }));
            pedestal.position.set(-4.5, 0.6, -9);
            pedestal.userData.isSolid = true;
            scene.add(pedestal);

            resetButtonMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), new THREE.MeshLambertMaterial({ color: 0xaa2222 }));
            resetButtonMesh.position.set(-4.5, 1.3, -9);
            scene.add(resetButtonMesh);

            createNPC();

            scene.updateMatrixWorld(true);
            scene.traverse(o => { if(o.userData.isSolid) addCollider(o); });
            const npcBox = new THREE.Box3();
            npcBox.setFromCenterAndSize(new THREE.Vector3(4, 0.9, -8), new THREE.Vector3(1, 2, 1));
            colliders.push(npcBox);
        }

        function createTorch(parent, x, y, z) {
            const torchGroup = new THREE.Group();
            torchGroup.position.set(x, 2.8, 0.2); 
            torchGroup.rotation.z = x > 0 ? -0.5 : 0.5; 
            parent.add(torchGroup);
            torchGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8), new THREE.MeshStandardMaterial({ color: 0x221100 })));
            const flame = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3, 6), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
            flame.position.y = 0.4;
            torchGroup.add(flame);
            const light = new THREE.PointLight(0xffaa00, 0, 8); // Off initially
            light.position.y = 0.5;
            torchGroup.add(light);
            fireLights.push({ light: light, base: 1.0, flicker: 0.2 });
        }

        function createCampfire(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            scene.add(group);
            for(let i=0; i<3; i++) {
                const log = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), new THREE.MeshStandardMaterial({ color: 0x332211 }));
                log.rotation.z = Math.PI/2; log.rotation.y = i * (Math.PI/3); log.position.y = 0.1;
                group.add(log);
            }
            const fire = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1, 6), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
            fire.position.y = 0.5; group.add(fire);
            const light = new THREE.PointLight(0xff6600, 0, 20); // Off initially
            light.position.y = 1.0; group.add(light);
            fireLights.push({ light: light, base: 2.0, flicker: 0.5 });
            const box = new THREE.Box3();
            box.setFromCenterAndSize(new THREE.Vector3(x, 0.5, z), new THREE.Vector3(1.5, 1, 1.5));
            colliders.push(box);
        }

        function createNPC() {
            const npcGroup = new THREE.Group();
            npcGroup.position.set(4, 0, -8);
            npcGroup.rotation.y = -Math.PI / 4; 
            scene.add(npcGroup);
            npcMesh = npcGroup;

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 2.2, 8), new THREE.MeshLambertMaterial({ color: 0x223355 })); // Blue suit initially
            body.position.y = 1.1; 
            body.name = 'body';
            npcGroup.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshLambertMaterial({ color: 0xffccaa })); // Skin tone
            head.position.y = 2.4; 
            head.name = 'head';
            npcGroup.add(head);
            
            const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.05, 12), new THREE.MeshLambertMaterial({ color: 0x222 }));
            brim.position.y = 2.7; 
            brim.name = 'brim';
            npcGroup.add(brim);
            
            const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.4, 12), new THREE.MeshLambertMaterial({ color: 0x222 }));
            hatTop.position.y = 2.9; 
            hatTop.name = 'hatTop';
            npcGroup.add(hatTop);

            const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black eyes initially
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-0.12, 2.45, 0.28); leftEye.name = 'eye'; npcGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(0.12, 2.45, 0.28); rightEye.name = 'eye'; npcGroup.add(rightEye);
            npcEyes = [leftEye, rightEye];

            // Add Smile (Torus)
            const mouthGeo = new THREE.TorusGeometry(0.1, 0.03, 8, 8, Math.PI); // Half circle smile
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            npcMouth = new THREE.Mesh(mouthGeo, mouthMat);
            npcMouth.rotation.z = Math.PI; // Smile upwards
            npcMouth.position.set(0, 2.25, 0.32); // Positioned on face
            npcMouth.name = 'mouth';
            npcGroup.add(npcMouth);
        }

        function createRain() {
            rainGeo = new THREE.BufferGeometry();
            const rainCount = CONFIG.rainCount;
            const positions = new Float32Array(rainCount * 3);
            for(let i=0; i<rainCount*3; i+=3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i+1] = Math.random() * 40;
                positions[i+2] = (Math.random() - 0.5) * 100;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainSystem = new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1, transparent: true, opacity: 0.6 }));
            rainSystem.visible = false; // Hidden initially
            scene.add(rainSystem);
        }

        function setupControls() {
            controls = new THREE.Object3D(); controls.rotation.order = 'YXZ'; 
            pitchObj = new THREE.Object3D(); pitchObj.rotation.order = 'YXZ';
            pitchObj.add(camera); controls.add(pitchObj); scene.add(controls);
            controls.position.y = CONFIG.playerHeight;

            handsGroup = new THREE.Group(); pitchObj.add(handsGroup); 
            const handGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const handMat = new THREE.MeshLambertMaterial({ color: 0xffccaa }); // Skin tone
            leftHand = new THREE.Mesh(handGeo, handMat); leftHand.position.set(-0.3, -0.3, -0.5); handsGroup.add(leftHand);
            rightHand = new THREE.Mesh(handGeo, handMat); rightHand.position.set(0.3, -0.3, -0.5); handsGroup.add(rightHand);

            document.addEventListener('pointerlockchange', () => {
                const blocker = document.getElementById('blocker');
                if (document.pointerLockElement === document.body) {
                    STATE.isPlaying = true; 
                    STATE.isDialogue = false; 
                    blocker.style.display = 'none';
                } else {
                    if (STATE.isDialogue || STATE.isContract) { 
                        STATE.isPlaying = false; 
                    } else {
                        STATE.isPlaying = false;
                        blocker.style.display = 'flex';
                        if (STATE.hasStarted) showMenu('pause');
                        else showMenu('start');
                    }
                }
            });
        }

        // Mobile Controls Wireup
        function setupMobileControls() {
            const btnPause = document.getElementById('btn-pause-mobile');
            const btnUp = document.getElementById('btn-up');
            const btnDown = document.getElementById('btn-down');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnJump = document.getElementById('btn-jump-mobile');
            const btnInteract = document.getElementById('btn-interact-mobile');

            btnPause.addEventListener('touchstart', (e) => { e.preventDefault(); showMenu('pause'); document.getElementById('blocker').style.display = 'flex'; STATE.isPlaying = false; });
            
            const handleMoveBtn = (btn, dir, val) => {
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); switch(dir){ case 'f': moveForward=true; break; case 'b': moveBackward=true; break; case 'l': moveLeft=true; break; case 'r': moveRight=true; break;} });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); switch(dir){ case 'f': moveForward=false; break; case 'b': moveBackward=false; break; case 'l': moveLeft=false; break; case 'r': moveRight=false; break;} });
            };

            handleMoveBtn(btnUp, 'f');
            handleMoveBtn(btnDown, 'b');
            handleMoveBtn(btnLeft, 'l');
            handleMoveBtn(btnRight, 'r');

            btnJump.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (canJump && !STATE.isDialogue && !STATE.isContract && !HUNT_STATE.isDragging) { velocity.y += CONFIG.jumpForce; canJump = false; }
            });

            btnInteract.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (STATE.isDialogue) advanceDialogue(); else tryInteract();
            });
        }

        function onTouchStart(e) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (!t.target.classList.contains('mobile-btn') && !t.target.closest('.menu-view')) {
                    if (touchDragId === null) {
                        lastTouchX = t.clientX;
                        lastTouchY = t.clientY;
                        touchDragId = t.identifier;
                    }
                }
            }
        }

        function onTouchMove(e) {
            if (STATE.isPlaying && !STATE.isDialogue && !STATE.isContract && !HORROR_STATE.isDead && !HUNT_STATE.isDragging) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchDragId) {
                        const touch = e.changedTouches[i];
                        const deltaX = touch.clientX - lastTouchX;
                        const deltaY = touch.clientY - lastTouchY;
                        controls.rotation.y -= deltaX * CONFIG.sensitivity;
                        pitchObj.rotation.x -= deltaY * CONFIG.sensitivity;
                        pitchObj.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObj.rotation.x));
                        lastTouchX = touch.clientX; lastTouchY = touch.clientY;
                        break;
                    }
                }
            }
        }

        function onTouchEnd(e) {
             for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchDragId) { touchDragId = null; break; }
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.body && !STATE.isDialogue && !STATE.isContract && !HORROR_STATE.isDead && !HUNT_STATE.isDragging) {
                controls.rotation.y -= event.movementX * CONFIG.sensitivity;
                pitchObj.rotation.x -= event.movementY * CONFIG.sensitivity;
                pitchObj.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObj.rotation.x));
            }
        }

        function onKeyDown(event) {
            if(HORROR_STATE.isDead || HUNT_STATE.isDragging) return;
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': case 'ShiftRight': STATE.isRunning = true; break;
                case 'Space': if (canJump && !STATE.isDialogue && !STATE.isContract) { velocity.y += CONFIG.jumpForce; canJump = false; } break;
                case 'KeyE': if (STATE.isDialogue) advanceDialogue(); else tryInteract(); break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'ShiftRight': STATE.isRunning = false; break;
            }
        }

        function checkCollision(pos) {
            playerBox.setFromCenterAndSize(pos, playerSize);
            for (let box of colliders) { if (playerBox.intersectsBox(box)) return true; }
            return false;
        }

        function onClick(event) {
            if (!STATE.isPlaying || STATE.isDialogue || STATE.isContract || HORROR_STATE.isDead || HUNT_STATE.isDragging) return;
            
            const coords = new THREE.Vector2();
            if (document.pointerLockElement) { coords.set(0, 0); } 
            else {
                coords.x = (event.clientX / window.innerWidth) * 2 - 1;
                coords.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            raycaster.setFromCamera(coords, camera);
            const intersects = raycaster.intersectObjects(boardMeshes);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const cellData = hit.object.userData;
                const dist = controls.position.distanceTo(hit.point);
                if (dist > CONFIG.interactDist + 2) return;
                if (STATE.gameActive && STATE.turn === 'player') attemptPlacePiece(cellData.index, cellData.row);
                return;
            }
        }

        function attemptPlacePiece(index, row) {
            if (STATE.board[index] !== null) { showNotification("Space occupied."); return; }
            if (row === 0 && controls.position.y < CONFIG.topRowHeightThreshold) {
                showNotification("Too high. Must JUMP."); playSound('click'); return;
            }
            makeMove(index, 'player');
        }

        function makeMove(index, who) {
            STATE.board[index] = who;
            const targetCell = boardMeshes[index];
            createPieceVisual(targetCell.position, who);
            if(who === 'player') playSound('placeX'); else playSound('placeO');

            if (checkWin(who)) { endGame(who); }
            else if (STATE.board.every(c => c !== null)) { endGame('draw'); }
            else {
                if (who === 'player') {
                    STATE.turn = 'npc';
                    document.getElementById('interact-prompt').innerText = HORROR_STATE.isActive ? "Dealer is thinking..." : "Opponent is thinking...";
                    setTimeout(aiTurn, 800 + Math.random() * 500);
                } else {
                    STATE.turn = 'player';
                    document.getElementById('interact-prompt').innerText = "Your move.";
                }
            }
        }

        function createPieceVisual(pos, type) {
            const visualPos = pos.clone();
            visualPos.z += 0.2;
            let mesh;
            if (type === 'player') {
                const group = new THREE.Group();
                const geo = new THREE.BoxGeometry(1, 0.2, 0.2);
                const mat = new THREE.MeshStandardMaterial({ color: HORROR_STATE.isActive ? 0xaa0000 : 0x225588, emissive: HORROR_STATE.isActive ? 0x330000 : 0x000000 });
                const bar1 = new THREE.Mesh(geo, mat); bar1.rotation.z = Math.PI/4;
                const bar2 = new THREE.Mesh(geo, mat); bar2.rotation.z = -Math.PI/4;
                group.add(bar1); group.add(bar2);
                mesh = group;
            } else {
                const geo = new THREE.TorusGeometry(0.4, 0.1, 8, 20);
                const mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                mesh = new THREE.Mesh(geo, mat);
            }
            mesh.position.set(boardMeshes[boardMeshes.length-1].parent.children.find(c => c.position.equals(pos)).position.x,
                              boardMeshes[boardMeshes.length-1].parent.children.find(c => c.position.equals(pos)).position.y, 0.5);
            boardGroup.add(mesh);
            placedPieces.push(mesh);
        }

        function aiTurn() {
            if (!STATE.gameActive) return;

            // Cheat Trigger Logic (Only in Horror Mode)
            if (HORROR_STATE.isActive && HORROR_STATE.gamesWon >= 3 && 
                HORROR_STATE.drawStreak >= HORROR_STATE.drawsBeforeCheating && 
                !HORROR_STATE.cheatUsedThisRound) {
                
                // ... Cheat logic same as before ...
                let targetIdx = -1;
                const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                for (let line of lines) {
                    let aiCount = 0, playerCount = 0, playerPos = -1;
                    line.forEach(idx => {
                        if(STATE.board[idx] === 'npc') aiCount++;
                        else if(STATE.board[idx] === 'player') { playerCount++; playerPos = idx; }
                    });
                    if (aiCount === 2 && playerCount === 1) { targetIdx = playerPos; break; }
                }
                if (targetIdx === -1) {
                    const playerIndices = STATE.board.map((v,i)=>v==='player'?i:-1).filter(i=>i!==-1);
                    if (playerIndices.length > 0) targetIdx = playerIndices[Math.floor(Math.random()*playerIndices.length)];
                }

                if (targetIdx !== -1) {
                    HORROR_STATE.cheatUsedThisRound = true;
                    playSound('scare');
                    setTimeout(() => {
                        doGlitchEffect();
                        speakDealer(DIALOGUE_CHEAT_EXECUTE[Math.floor(Math.random() * DIALOGUE_CHEAT_EXECUTE.length)]);
                        const cellPos = boardMeshes[targetIdx].position;
                        let closestPiece = null, minD = 999, closestIdx = -1;
                        placedPieces.forEach((p, i) => {
                            const d = p.position.distanceTo(cellPos);
                            if(d < 0.5) { minD = d; closestPiece = p; closestIdx = i; }
                        });
                        if(closestPiece) { boardGroup.remove(closestPiece); placedPieces.splice(closestIdx, 1); }
                        STATE.board[targetIdx] = 'npc';
                        createPieceVisual(cellPos, 'npc');
                        playSound('placeO');
                        if (checkWin('npc')) { endGame('npc'); return; }
                        const available = STATE.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
                        if (available.length > 0) makeMove(available[Math.floor(Math.random() * available.length)], 'npc');
                        else endGame('npc');
                    }, 800);
                    return;
                }
            }

            // Standard Move Logic
            let move;
            // Easy mode always active in Happy Mode or early Horror Mode
            if (!HORROR_STATE.isActive || HORROR_STATE.gamesWon < CONFIG.initialEasyWins) {
                const available = STATE.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
                move = available[Math.floor(Math.random() * available.length)];
            } else {
                move = getBestMove(STATE.board, 'npc');
            }
            if (move !== undefined) makeMove(move, 'npc');
        }

        function getBestMove(board, player) {
            let bestScore = -Infinity;
            let move;
            for(let i=0; i<9; i++) {
                if(board[i]===null) {
                    board[i] = player;
                    let score = minimax(board, 0, false);
                    board[i] = null;
                    if(score > bestScore) { bestScore = score; move = i; }
                }
            }
            return move;
        }

        const scores = { npc: 10, player: -10, tie: 0 };
        function minimax(board, depth, isMaximizing) {
            let result = checkWinnerSim(board);
            if (result !== null) return scores[result];
            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = 'npc';
                        let score = minimax(board, depth + 1, false);
                        board[i] = null;
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = 'player';
                        let score = minimax(board, depth + 1, true);
                        board[i] = null;
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }
        function checkWinnerSim(board) {
            const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            for (let line of lines) {
                const [a, b, c] = line;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) return board[a];
            }
            if (board.every(c => c !== null)) return 'tie';
            return null;
        }
        function checkWin(who) { return checkWinnerSim(STATE.board) === who; }

        function endGame(result) {
            STATE.gameActive = false;
            STATE.gameEnded = true; 
            
            if (result === 'player') {
                HORROR_STATE.gamesWon++;
                HORROR_STATE.currentWinnings += 1000000;
                HORROR_STATE.drawStreak = 0;
                playSound('cash');
                updateHUD();
                showNotification(HORROR_STATE.isActive ? "PAYMENT RECEIVED." : "You Win!");
                
                // TRANSITION TRIGGER
                if (HORROR_STATE.gamesWon === CONFIG.initialEasyWins && !HORROR_STATE.isActive) {
                    speakDealer("Easy... right?");
                    setTimeout(activateHorrorMode, 2000); // 2 second gap then switch
                } else {
                    setTimeout(resetBoard, 3000);
                }

            } else if (result === 'npc') {
                HORROR_STATE.drawStreak = 0;
                if(HORROR_STATE.cheatUsedThisRound) {
                    HORROR_STATE.drawsBeforeCheating = Math.floor(Math.random() * 3) + 1; 
                }

                // If in Happy Mode, no hunt. Just reset.
                if (!HORROR_STATE.isActive) {
                    speakDealer("Oops! Better luck next time.");
                    showNotification("You Lost");
                    setTimeout(resetBoard, 2000);
                } else {
                    // Horror Mode: Hunt
                    triggerHunt(); 
                }

            } else {
                // Stalemate 
                if (HORROR_STATE.gamesWon >= CONFIG.initialEasyWins) {
                    HORROR_STATE.drawStreak++;
                }
                playSound('place'); 
                showNotification(HORROR_STATE.isActive ? "STALEMATE." : "Draw Game");
                setTimeout(resetBoard, 3000);
            }
        }

        function activateHorrorMode() {
            HORROR_STATE.isActive = true;
            document.body.classList.add('horror-mode');
            
            // Visual Updates
            scene.background = new THREE.Color(0x050810);
            scene.fog = new THREE.FogExp2(0x050810, CONFIG.fogDensity);
            
            // Material Swaps
            groundMat.color.setHex(0x1a1510);
            treeLeafMat.color.setHex(0x0a1a0a);
            treeTrunkMat.color.setHex(0x110d0a);
            skyCloudMat.color.setHex(0x111122); skyCloudMat.opacity = 0.6;

            // Light Swaps
            scene.remove(sunLight);
            scene.remove(ambientLight);
            const darkAmb = new THREE.AmbientLight(0x444455);
            scene.add(darkAmb);

            fireLights.forEach(f => f.light.intensity = 1.0); // Turn on fire
            rainSystem.visible = true; // Turn on rain

            // NPC Visual Update
            // Darken suit, red eyes, pale skin
            npcMesh.children.forEach(c => {
                if(c.name === 'body') c.material.color.setHex(0x110d0a);
                if(c.name === 'head') c.material.color.setHex(0xccccaa);
                if(c.name === 'eye') c.material.color.setHex(0xff0000);
            });

            // Audio Swap
            if(audioCtx) {
                if(happyAmbienceNode) { happyAmbienceNode.stop(); happyAmbienceNode.disconnect(); }
                startAmbience(); // Starts horror ambience
            }

            playSound('scare');
            showNotification("THE CONTRACT BEGINS");
            
            setTimeout(resetBoard, 3000);
        }

        function triggerHunt() {
            const huntUI = document.getElementById('hunt-ui');
            const huntCD = document.getElementById('hunt-countdown');
            huntUI.style.display = 'block';
            HUNT_STATE.timer = 3;
            huntCD.innerText = HUNT_STATE.timer;
            playSound('scare');
            speakDealer("You... should... run.");
            const interval = setInterval(() => {
                HUNT_STATE.timer--;
                if (HUNT_STATE.timer > 0) {
                    huntCD.innerText = HUNT_STATE.timer;
                    playSound('click');
                } else {
                    clearInterval(interval);
                    huntUI.style.display = 'none';
                    startHunt();
                }
            }, 1000);
        }

        function startHunt() {
            HUNT_STATE.active = true;
            HUNT_STATE.npcFootstepTimer = 0;
            showNotification("SURVIVE");
            playSound('scare');
        }

        function updateHunt(delta) {
            if (!HUNT_STATE.active) return;
            const playerPos = controls.position.clone();
            const npcPos = npcMesh.position.clone();
            const dir = new THREE.Vector3().subVectors(playerPos, npcPos).normalize();
            dir.y = 0; 
            const speed = (STATE.isRunning) ? HUNT_STATE.npcSprintSpeed : HUNT_STATE.npcSpeed;
            npcMesh.position.add(dir.multiplyScalar(speed * delta));
            npcMesh.lookAt(playerPos.x, npcMesh.position.y, playerPos.z);
            HUNT_STATE.npcFootstepTimer += delta;
            const stepInterval = (STATE.isRunning) ? 0.35 : 0.5;
            if (HUNT_STATE.npcFootstepTimer > stepInterval) {
                playSound('thump');
                HUNT_STATE.npcFootstepTimer = 0;
            }
            const dx = playerPos.x - npcPos.x;
            const dz = playerPos.z - npcPos.z;
            const dist2D = Math.sqrt(dx*dx + dz*dz);
            if (dist2D < HUNT_STATE.captureDist) { doJumpscare(); }
        }

        function doJumpscare() {
            HUNT_STATE.active = false;
            HUNT_STATE.isJumpscaring = true; // Keeps shake

            // Stop player
            velocity.set(0,0,0);
            moveForward = moveBackward = moveLeft = moveRight = false;

            // Audio
            playSound('scream');

            // Show 2D Overlay
            const overlay = document.getElementById('jumpscare-overlay');
            overlay.style.display = 'flex'; // Use flex to center face

            // logic to hide later
            setTimeout(() => {
                HUNT_STATE.isJumpscaring = false;
                overlay.style.display = 'none';
                capturePlayer();
            }, 1500); // Maybe slightly longer for the zoom in/out effect to register
        }

        function capturePlayer() {
            HUNT_STATE.active = false;
            HUNT_STATE.isDragging = true;
            HUNT_STATE.isExtracting = true; 
            HUNT_STATE.dragStartTime = performance.now();
            HUNT_STATE.dragStartPos = controls.position.clone();
            velocity.set(0,0,0);
            moveForward = moveBackward = moveLeft = moveRight = false;
            playSound('crunch');
            showNotification("CAUGHT");
            applyBloodVignette(3); 
        }

        function updateDrag() {
            const elapsed = performance.now() - HUNT_STATE.dragStartTime;
            const progress = Math.min(elapsed / HUNT_STATE.dragDuration, 1.0);
            const ease = 1 - Math.pow(1 - progress, 3);
            const targetPos = new THREE.Vector3(0, CONFIG.playerHeight, -2);
            controls.position.lerpVectors(HUNT_STATE.dragStartPos, targetPos, ease);
            const shake = (1.0 - progress) * 0.1;
            controls.position.x += (Math.random() - 0.5) * shake;
            controls.position.y += (Math.random() - 0.5) * shake;
            const npcTargetPos = new THREE.Vector3(0, 0, -4); 
            npcMesh.position.lerpVectors(HUNT_STATE.dragStartPos, npcTargetPos, ease);
            npcMesh.lookAt(controls.position.x, 0, controls.position.z);
            pitchObj.rotation.x = THREE.MathUtils.lerp(pitchObj.rotation.x, 0, 0.1);
            const targetLook = new THREE.Vector3(npcMesh.position.x, CONFIG.playerHeight, npcMesh.position.z);
            controls.lookAt(targetLook);
            if (progress >= 1.0) {
                HUNT_STATE.isDragging = false;
                finishDrag();
            }
        }

        function finishDrag() {
            npcMesh.position.set(0, 0, -4.5);
            npcMesh.lookAt(controls.position.x, 0, controls.position.z);
            // Ensure visibility is restored (just in case)
            npcMesh.children.forEach(c => c.visible = true);
            handleBodyPartLoss();
        }

        function handleBodyPartLoss() {
            const partIdx = HORROR_STATE.bodyParts.findIndex(p => !p.lost);
            if (partIdx === -1) return;
            const part = HORROR_STATE.bodyParts[partIdx];
            playSound('scare'); 
            setTimeout(() => {
                part.lost = true;
                playSound('crunch');
                updateHUD(); 
                applyBloodVignette(partIdx);
                if (part.name === "Soul") {
                    speakDealer("Your debt... is paid.");
                    triggerDeath();
                } else {
                    showNotification(`LOST: ${part.name.toUpperCase()}`);
                    speakDealer(DIALOGUE_BODY_PART_LOSS[Math.floor(Math.random() * DIALOGUE_BODY_PART_LOSS.length)]);
                    setTimeout(resetBoard, 2000);
                }
            }, 1000);
        }

        function applyBloodVignette(stage) {
            const opacity = (stage + 1) * 0.15;
            const vignette = document.getElementById('vignette');
            const centerSize = Math.max(0, 60 - stage * 8); 
            vignette.style.background = `radial-gradient(circle, transparent ${centerSize}%, rgba(${80 + stage * 20}, 0, 0, ${opacity}) 100%)`;
        }

        function triggerDeath() {
            HORROR_STATE.isDead = true;
            document.getElementById('notification').innerText = "CONTRACT TERMINATED.";
            document.getElementById('notification').style.opacity = 1;
            const blocker = document.getElementById('blocker');
            blocker.style.display = 'flex';
            blocker.style.backgroundColor = 'black';
            blocker.innerHTML = `<h1 style='color:#500'>VOID</h1><p>Refresh to resurrect.</p>`;
            document.exitPointerLock();
        }

        function doGlitchEffect() {
            playSound('glitch');
            const originalRot = camera.rotation.z;
            let glitchFrames = 20;
            const interval = setInterval(() => {
                camera.rotation.z = (Math.random() - 0.5) * 0.5;
                scene.fog.density = Math.random() * 0.1;
                glitchFrames--;
                if(glitchFrames <= 0) {
                    clearInterval(interval);
                    camera.rotation.z = originalRot;
                    scene.fog.density = CONFIG.fogDensity;
                }
            }, 50);
        }

        function resetBoard() {
            if(HORROR_STATE.isDead) return;
            HUNT_STATE.isExtracting = false; 
            npcMesh.position.copy(HUNT_STATE.npcStartPos);
            npcMesh.rotation.set(0, -Math.PI/4, 0);
            
            // Ensure full body is visible
            npcMesh.children.forEach(c => c.visible = true);

            STATE.board = Array(9).fill(null);
            placedPieces.forEach(m => boardGroup.remove(m));
            placedPieces = [];
            STATE.gameActive = true;
            STATE.gameEnded = false;
            STATE.turn = 'player';
            document.getElementById('interact-prompt').innerText = "Your move.";
            HORROR_STATE.cheatUsedThisRound = false;
            resetButtonMesh.material.emissive.setHex(0x220000);
            showNotification("");

            if (HORROR_STATE.isActive && HORROR_STATE.gamesWon >= CONFIG.initialEasyWins && 
                HORROR_STATE.drawStreak >= HORROR_STATE.drawsBeforeCheating) {
                setTimeout(() => { playSound('scare'); }, 500); 
                showNotification(DIALOGUE_CHEAT_WARNING[Math.floor(Math.random() * DIALOGUE_CHEAT_WARNING.length)]);
            }
        }

        function updateHUD() {
            document.getElementById('winnings-display').innerText = "$" + HORROR_STATE.currentWinnings.toLocaleString();
            const bar = document.getElementById('body-parts-bar');
            bar.innerHTML = "";
            HORROR_STATE.bodyParts.forEach(p => {
                const el = document.createElement('div');
                el.className = "body-part" + (p.lost ? " lost" : "");
                el.innerText = p.name;
                bar.appendChild(el);
            });
        }

        function setupInteractUI() { updateHUD(); }

        let dialogueIndex = 0;
        function tryInteract() {
            const dist = controls.position.distanceTo(npcMesh.position);
            if (dist < CONFIG.interactDist) { startDialogue(); }
        }

        function startDialogue() {
            if (HORROR_STATE.contractSigned && STATE.gameActive) return;
            if (HORROR_STATE.contractSigned && !STATE.gameActive) { showNotification("The board is waiting."); return; }
            STATE.isDialogue = true;
            dialogueIndex = 0;
            if (!STATE.isMobile) document.exitPointerLock(); 
            document.getElementById('dialogue-container').style.display = 'block';
            updateDialogue();
        }

        function updateDialogue() {
            const txt = document.getElementById('dialogue-text');
            const btn = document.getElementById('dialogue-btn');
            
            let lines = HORROR_STATE.isActive ? DIALOGUE_HORROR_INTRO : DIALOGUE_HAPPY;

            if (dialogueIndex < lines.length) {
                const line = lines[dialogueIndex];
                txt.innerText = line;
                btn.innerText = "Next";
                speakDealer(line);
                npcMesh.rotation.z = (Math.random() - 0.5) * 0.2;
            } else { endDialogue(); }
        }
        function advanceDialogue() { 
            dialogueIndex++; 
            playSound('click');
            if(audioCtx) stopHorrorDrone();
            updateDialogue(); 
        }
        function endDialogue() {
            STATE.isDialogue = false;
            document.getElementById('dialogue-container').style.display = 'none';
            showContract();
        }

        function showContract() {
            STATE.isContract = true;
            document.getElementById('contract-container').style.display = 'flex';
            speakDealer("Sign... here.");
            setupSignatureCanvas();
        }

        function setupSignatureCanvas() {
            const canvas = document.getElementById('signature-area');
            const ctx = canvas.getContext('2d');
            let drawing = false;
            ctx.lineWidth = 2; ctx.strokeStyle = "#220000"; 
            function getCoords(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } 
                else { clientX = e.clientX; clientY = e.clientY; }
                const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }
            function startDraw(e) { if (e.cancelable) e.preventDefault(); drawing = true; const pos = getCoords(e); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); }
            function moveDraw(e) { if (e.cancelable) e.preventDefault(); if (!drawing) return; const pos = getCoords(e); ctx.lineTo(pos.x, pos.y); ctx.stroke(); }
            function stopDraw(e) { if (e.cancelable) e.preventDefault(); drawing = false; }
            canvas.onmousedown = startDraw; canvas.onmousemove = moveDraw; canvas.onmouseup = stopDraw; canvas.onmouseout = stopDraw;
            canvas.ontouchstart = startDraw; canvas.ontouchmove = moveDraw; canvas.ontouchend = stopDraw;

            document.getElementById('sign-btn').onclick = () => {
                document.getElementById('contract-container').style.display = 'none';
                STATE.isContract = false;
                HORROR_STATE.contractSigned = true;
                document.getElementById('body-parts-bar').style.display = 'flex';
                updateHUD();
                if(!STATE.isMobile) document.body.requestPointerLock();
                playSound('crunch'); 
                resetBoard();
                showNotification(HORROR_STATE.isActive ? "CONTRACT SEALED." : "Game On!");
            };
        }

        function showNotification(text) {
            const el = document.getElementById('notification');
            el.innerText = text;
            el.style.opacity = 1;
            if(el.timeout) clearTimeout(el.timeout);
            el.timeout = setTimeout(() => { el.style.opacity = 0; }, 3000);
        }

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            
            // Happy Ambience (Soft Wind)
            const bSize = audioCtx.sampleRate * 2;
            const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for(let i=0; i<bSize; i++) d[i] = (Math.random()*2-1); // Raw white noise
            happyAmbienceNode = audioCtx.createBufferSource();
            happyAmbienceNode.buffer = buf;
            happyAmbienceNode.loop = true;
            
            // Filter to remove rain-like frequencies
            const hFilter = audioCtx.createBiquadFilter();
            hFilter.type = 'lowpass';
            hFilter.frequency.value = 400; // Wind-like cutoff

            const hGain = audioCtx.createGain(); 
            hGain.gain.value = 0.1; // Soft volume

            happyAmbienceNode.connect(hFilter);
            hFilter.connect(hGain);
            hGain.connect(masterGain);
            happyAmbienceNode.start();
            
            // Setup Horror Nodes (but don't start)
            demonOsc1 = audioCtx.createOscillator(); demonOsc1.type = 'sawtooth'; demonOsc1.frequency.value = 30; 
            demonOsc2 = audioCtx.createOscillator(); demonOsc2.type = 'square'; demonOsc2.frequency.value = 35; demonOsc2.detune.value = 15;
            demonGain = audioCtx.createGain(); demonGain.gain.value = 0; 
            demonFilter = audioCtx.createBiquadFilter(); demonFilter.type = 'lowpass'; demonFilter.frequency.value = 200; 
            demonShaper = audioCtx.createWaveShaper();
            const curve = new Float32Array(4096);
            for (let i = 0; i < 4096; i++) { const x = i * 2 / 4096 - 1; curve[i] = (3 + 20) * x * 20 * (Math.PI / 180) / (Math.PI + 20 * Math.abs(x)); }
            demonShaper.curve = curve;
            demonOsc1.connect(demonFilter); demonOsc2.connect(demonFilter);
            demonFilter.connect(demonShaper); demonShaper.connect(demonGain); demonGain.connect(masterGain); 
            demonOsc1.start(); demonOsc2.start();

            // Happy Talk Synth
            happyTalkOsc = audioCtx.createOscillator(); happyTalkOsc.type = 'sine';
            happyTalkGain = audioCtx.createGain(); happyTalkGain.gain.value = 0;
            happyTalkOsc.connect(happyTalkGain); happyTalkGain.connect(masterGain);
            happyTalkOsc.start();
        }

        function speakDealer(text) {
            if(HORROR_STATE.isActive) {
                startHorrorDrone();
                setTimeout(stopHorrorDrone, 1500); 
            } else {
                startHappyTalk();
                setTimeout(stopHappyTalk, 1000);
            }
        }

        function startHorrorDrone() {
            if(demonGain) {
                demonGain.gain.cancelScheduledValues(audioCtx.currentTime);
                demonGain.gain.setValueAtTime(0, audioCtx.currentTime);
                demonGain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.1); 
            }
        }
        function stopHorrorDrone() {
            if(demonGain) {
                demonGain.gain.cancelScheduledValues(audioCtx.currentTime);
                demonGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
            }
        }
        function startHappyTalk() {
            if(happyTalkGain) {
                happyTalkOsc.frequency.setValueAtTime(400, audioCtx.currentTime);
                happyTalkOsc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.5);
                happyTalkGain.gain.setValueAtTime(0, audioCtx.currentTime);
                happyTalkGain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.1);
            }
        }
        function stopHappyTalk() {
            if(happyTalkGain) happyTalkGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
        }

        function startAmbience() {
            // Horror Ambience
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0; 
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }
            rainNode = audioCtx.createBufferSource();
            rainNode.buffer = buffer;
            rainNode.loop = true;
            const gain = audioCtx.createGain();
            gain.gain.value = 0.15; 
            rainNode.connect(gain);
            gain.connect(masterGain); 
            rainNode.start();

            const osc = audioCtx.createOscillator();
            osc.type = 'sine'; osc.frequency.value = 50;
            const droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.2; 
            osc.connect(droneGain);
            droneGain.connect(masterGain); 
            osc.start();
        }

        function playSound(type) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(masterGain);

            if (type === 'click') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(800, t);
                gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
                osc.start(t); osc.stop(t+0.1);
            }
            else if (type === 'placeX') {
                osc.type = 'square'; osc.frequency.setValueAtTime(HORROR_STATE.isActive ? 100 : 400, t);
                gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            }
            else if (type === 'placeO') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(HORROR_STATE.isActive ? 80 : 350, t);
                gain.gain.setValueAtTime(0.4, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.3);
                osc.start(t); osc.stop(t+0.3);
            }
            else if (type === 'cash') {
                const o1 = audioCtx.createOscillator(); o1.type = 'sine'; o1.frequency.setValueAtTime(1000, t); o1.frequency.exponentialRampToValueAtTime(2000, t + 0.1);
                const g1 = audioCtx.createGain(); g1.gain.setValueAtTime(0.6, t); g1.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                o1.connect(g1); g1.connect(masterGain); o1.start(t); o1.stop(t + 0.4);
                const o2 = audioCtx.createOscillator(); o2.type = 'square'; o2.frequency.setValueAtTime(3000, t + 0.1);
                const g2 = audioCtx.createGain(); g2.gain.setValueAtTime(0.4, t + 0.1); g2.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                o2.connect(g2); g2.connect(masterGain); o2.start(t + 0.1); o2.stop(t + 0.6);
            }
            else if (type === 'scare') {
                [400, 440, 485].forEach(f => {
                    const o = audioCtx.createOscillator(); o.type = 'sawtooth'; o.frequency.value = f;
                    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t+1.5);
                    o.connect(g); g.connect(masterGain); o.start(t); o.stop(t+1.5);
                });
            }
            else if (type === 'crunch') {
                const bSize = audioCtx.sampleRate * 0.5; const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate); const d = buf.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
                const n = audioCtx.createBufferSource(); n.buffer = buf;
                const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 1000;
                const g = audioCtx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.4);
                n.connect(f); f.connect(g); g.connect(masterGain); n.start(t);
            }
            else if (type === 'thunder') {
                const bSize = audioCtx.sampleRate * 1.0; const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate); const d = buf.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
                const n = audioCtx.createBufferSource(); n.buffer = buf;
                const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 200;
                const g = audioCtx.createGain(); g.gain.setValueAtTime(1.0, t); g.gain.exponentialRampToValueAtTime(0.01, t+1.0);
                n.connect(f); f.connect(g); g.connect(masterGain); n.start(t);
            }
            else if (type === 'glitch') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, t); osc.frequency.linearRampToValueAtTime(2000, t+0.1);
                gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            }
            else if (type === 'step') {
                 const bSize = audioCtx.sampleRate * 0.15; const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate); const d = buf.getChannelData(0);
                 for(let i=0; i<bSize; i++) d[i] = (Math.random() * 2 - 1) * 0.5;
                 const n = audioCtx.createBufferSource(); n.buffer = buf;
                 const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 600;
                 const g = audioCtx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                 n.connect(f); f.connect(g); g.connect(masterGain); n.start(t);
            }
            else if (type === 'thump') {
                 const bSize = audioCtx.sampleRate * 0.2; const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate); const d = buf.getChannelData(0);
                 for(let i=0; i<bSize; i++) d[i] = (Math.random() * 2 - 1);
                 const n = audioCtx.createBufferSource(); n.buffer = buf;
                 const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 200;
                 const g = audioCtx.createGain(); g.gain.setValueAtTime(1.0, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
                 n.connect(f); f.connect(g); g.connect(masterGain); n.start(t);
            }
            else if (type === 'scream') {
                 // High pitched chaos
                 const o = audioCtx.createOscillator(); o.type = 'sawtooth'; o.frequency.setValueAtTime(400, t); 
                 o.frequency.exponentialRampToValueAtTime(1200, t+0.1);
                 o.frequency.exponentialRampToValueAtTime(100, t+0.8);
                 const g = audioCtx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.8);
                 const d = audioCtx.createDelay(); d.delayTime.value = 0.05;
                 
                 o.connect(g); g.connect(d); d.connect(masterGain); g.connect(masterGain);
                 o.start(t); o.stop(t+0.8);

                 // Sub noise
                 const bSize = audioCtx.sampleRate * 0.8; const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate); 
                 const data = buf.getChannelData(0); for(let i=0; i<bSize; i++) data[i] = Math.random() * 2 - 1;
                 const n = audioCtx.createBufferSource(); n.buffer = buf;
                 const nf = audioCtx.createBiquadFilter(); nf.type = 'highpass'; nf.frequency.value = 1000;
                 const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.5, t); ng.gain.linearRampToValueAtTime(0, t+0.5);
                 n.connect(nf); nf.connect(ng); ng.connect(masterGain); n.start(t);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (STATE.isPlaying && !STATE.isDialogue && !STATE.isContract && !HORROR_STATE.isDead && !HUNT_STATE.isDragging && !HUNT_STATE.isExtracting && !HUNT_STATE.isJumpscaring) {
                controls.rotation.x = 0; controls.rotation.z = 0;
                const time = performance.now(); const delta = (time - prevTime) / 1000; prevTime = time;
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= CONFIG.gravity * delta;
                direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize();
                const currentSpeed = CONFIG.moveSpeed * (STATE.isRunning ? CONFIG.runSpeedMultiplier : 1.0);
                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;
                const localMove = new THREE.Vector3(-velocity.x * delta, 0, velocity.z * delta);
                const worldMove = localMove.clone().applyQuaternion(controls.quaternion);
                controls.position.x += worldMove.x; if(checkCollision(controls.position)) { controls.position.x -= worldMove.x; velocity.x = 0; }
                controls.position.z += worldMove.z; if(checkCollision(controls.position)) { controls.position.z -= worldMove.z; velocity.z = 0; }
                controls.position.y += velocity.y * delta;
                
                // Ground Collision
                let onGround = false;
                if (controls.position.y < CONFIG.playerHeight) { 
                    velocity.y = 0; 
                    controls.position.y = CONFIG.playerHeight; 
                    canJump = true; 
                    onGround = true; 
                }

                const isMoving = (moveForward || moveBackward || moveLeft || moveRight);
                if (isMoving && onGround) {
                    const bobFreq = STATE.isRunning ? 15 : 10; const bobAmp = STATE.isRunning ? 0.15 : 0.08; const t = time / 1000;
                    camera.position.y = Math.sin(t * bobFreq) * bobAmp;
                    handsGroup.position.y = Math.sin(t * bobFreq) * bobAmp * 1.5 - 0.2; handsGroup.position.x = Math.cos(t * bobFreq * 0.5) * 0.05;
                    
                    footstepTimer += delta;
                    // Calculate interval: 1.4x faster sound when sprinting
                    const currentInterval = STATE.isRunning ? (CONFIG.footstepInterval / 1.4) : CONFIG.footstepInterval;
                    
                    if (footstepTimer > currentInterval) {
                        playSound('step');
                        footstepTimer = 0;
                    }
                } else {
                    camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0, 0.1);
                    handsGroup.position.y = THREE.MathUtils.lerp(handsGroup.position.y, -0.2, 0.1);
                }
                const distNPC = controls.position.distanceTo(npcMesh.position);
                const interactText = document.getElementById('interact-prompt');
                if (distNPC < CONFIG.interactDist && !HUNT_STATE.active) {
                    interactText.style.display = 'block';
                    if(!HORROR_STATE.contractSigned) interactText.innerText = "[E] Speak";
                    if(STATE.isMobile) document.getElementById('btn-interact-mobile').style.display = 'flex';
                } else { 
                    interactText.style.display = 'none'; 
                    if(STATE.isMobile) document.getElementById('btn-interact-mobile').style.display = 'none';
                }
                
                // Update Hunt logic
                updateHunt(delta);
                
            } else if (HUNT_STATE.isJumpscaring) {
                // Jumpscare Shake
                controls.rotation.z = (Math.random() - 0.5) * 0.2;
                camera.position.x += (Math.random() - 0.5) * 0.05;
                camera.position.y += (Math.random() - 0.5) * 0.05;
            } else if (HUNT_STATE.isDragging) {
                // Keep updating drag animation
                updateDrag();
            } else { prevTime = performance.now(); }

            if(npcMesh && !HUNT_STATE.active && !HUNT_STATE.isDragging && !HUNT_STATE.isExtracting && !HUNT_STATE.isJumpscaring) { 
                const t = performance.now() / 2000; 
                npcMesh.position.y = Math.sin(t) * 0.05; 
                npcMesh.rotation.y = -Math.PI/4 + Math.sin(t*0.5) * 0.05; 
            }
            if(rainSystem) {
                const positions = rainSystem.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) { positions[i] -= 0.5; if(positions[i] < 0) positions[i] = 40; }
                rainSystem.geometry.attributes.position.needsUpdate = true;
            }
            fireLights.forEach(f => { f.light.intensity = f.base + (Math.random() - 0.5) * f.flicker; });
            
            // LIGHTNING LOGIC FIX: Guard with HORROR_STATE.isActive
            if(HORROR_STATE.isActive && Math.random() < 0.005) {
                flashLight.intensity = 2 + Math.random() * 5; setTimeout(() => { flashLight.intensity = 0; }, 100);
                setTimeout(() => { playSound('thunder'); }, 200 + Math.random() * 800); 
            }
            
            placedPieces.forEach(p => { p.rotation.z += 0.01; });
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
